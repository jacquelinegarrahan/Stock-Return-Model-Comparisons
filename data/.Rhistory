pbinom(4,12,0.2)
binom.test(4, 45, p=0.5, alternative=c("two.sided", "less", "greater"), conf.level=0.90)
binom.test(4, 45, p=0.1, alternative=c("two.sided", "less", "greater"), conf.level=0.90)
binom.test(4, 45, p=0.1, alternative=c("two.sided", "less", "greater"), conf.level=0.90)
pnorm(0, mean=0, sd=1)
pnorm(-2.134, mean=0, sd=1)
pnorm(-2.123, mean=0, sd=1)
binom.test(4, 45, p=0.22, alternative=c("two.sided", "less", "greater"), conf.level=0.95)
n =10000
prob = 0.1
z = 1.96
#generate n samples from the binomial distribution
samples <- binomial(n, prob)
x <- cumsum(samples)
n <=10000
prob <= 0.1
z <= 1.96
#generate n samples from the binomial distribution
samples <- binomial(n, prob)
x <- cumsum(samples)
#generate n samples from the binomial distribution
samples <- binomial(n, 0.1)
#generate n samples from the binomial distribution
samples <- Binomial(n, prob)
#generate n samples from the binomial distribution
samples <- rbinom(n, 1, prob)
x <- cumsum(samples)
x <- sum(samples)
print(WilsonInterval(sum(samples), n, z))
#function for calculating the Wilson interval
WilsonInterval <- function(x, n, z, print=FALSE) {
p <= x/n
upper <= (p + z^2/(2*n))/(1+z^2/n) + ((sqrt(n)*z)/(n+z^2))*sqrt(p*(1-p)+z^2/(4n))
lower <= (p + z^2/(2*n))/(1+z^2/n) - ((sqrt(n)*z)/(n+z^2))*sqrt(p*(1-p)+z^2/(4n))
return(result)
}
#function for calculating the Wilson interval
WilsonInterval <- function(x, n, z, print=FALSE) {
p <= x/n
upper <= (p + z^2/(2*n))/(1+z^2/n) + ((sqrt(n)*z)/(n+z^2))*sqrt(p*(1-p)+z^2/(4n))
lower <= (p + z^2/(2*n))/(1+z^2/n) - ((sqrt(n)*z)/(n+z^2))*sqrt(p*(1-p)+z^2/(4n))
}
#function for calculating the Wilson interval
WilsonInterval <- function(x, n, z, print=FALSE) {
p <= x/n
upper <= (p + z^2/(2*n))/(1+z^2/n) + ((sqrt(n)*z)/(n+z^2))*sqrt(p*(1-p)+z^2/(4n));
lower <= (p + z^2/(2*n))/(1+z^2/n) - ((sqrt(n)*z)/(n+z^2))*sqrt(p*(1-p)+z^2/(4n));
return(upper)
}
print(upper)
print(WilsonInterval(sum(samples), n, z))
p <- x/n
#function for calculating the Wilson interval
WilsonInterval <- function(x, n, z, print=FALSE) {
p <- x/n
upper <- (p + z^2/(2*n))/(1+z^2/n) + ((sqrt(n)*z)/(n+z^2))*sqrt(p*(1-p)+z^2/(4n));
lower <- (p + z^2/(2*n))/(1+z^2/n) - ((sqrt(n)*z)/(n+z^2))*sqrt(p*(1-p)+z^2/(4n));
return(upper)
}
#function for calculating the Wilson interval
WilsonInterval <- function(x, n, z, print=FALSE) {
p <- x/n
upper <- (p + z^2/(2*n))/(1+z^2/n) + ((sqrt(n)*z)/(n+z^2))*sqrt(p*(1-p)+z^2/(4n));
lower <- (p + z^2/(2*n))/(1+z^2/n) - ((sqrt(n)*z)/(n+z^2))*sqrt(p*(1-p)+z^2/(4n));
return(upper)
}
#function for calculating the Wilson interval
WilsonInterval <- function(x, n, z, print=FALSE) {
p <- x/n
upper <- (p + z^2/(2*n))/(1+z^2/n) + ((sqrt(n)*z)/(n+z^2))*sqrt(p*(1-p)+z^2/(4n))
lower <- (p + z^2/(2*n))/(1+z^2/n) - ((sqrt(n)*z)/(n+z^2))*sqrt(p*(1-p)+z^2/(4n))
return(upper)
}
p <- x/n
#function for calculating the Wilson interval
WilsonInterval <- function(x, n, z, print=FALSE) {
p <- x/n
upper <- (p + z^2/(2*n))/(1+z^2/n) + ((sqrt(n)*z)/(n+z^2))*sqrt(p*(1-p)+z^2/(4n))
lower <- (p + z^2/(2*n))/(1+z^2/n) - ((sqrt(n)*z)/(n+z^2))*sqrt(p*(1-p)+z^2/(4n))
return(upper)
}
#function for calculating the Wald interval
WaldInterval <- function(x, n, z, print=FALSE) {
p <= x/n
upper <= p + z* sqrt(p*(1-p)/n)
lower <= p - z* sqrt(p*(1-p)/n)
}
#function for calculating the Wilson interval
WilsonInterval <- function(x, n, z, print=FALSE) {
p <- x/n
upper <- (p + z**2/(2*n))/(1+z^2/n) + ((sqrt(n)*z)/(n+z**2))*sqrt(p*(1-p)+z**2/(4n))
lower <- (p + z**2/(2*n))/(1+z^2/n) - ((sqrt(n)*z)/(n+z**2))*sqrt(p*(1-p)+z**2/(4n))
return(upper)
}
print(WaldInterval(sum(samples), n, z))
#function for calculating the Wald interval
WaldInterval <- function(x, n, z, print=FALSE) {
p <= x/n
upper <- p + z* sqrt(p*(1-p)/n)
lower <- p - z* sqrt(p*(1-p)/n)
}
print(WaldInterval(sum(samples), n, z))
#function for calculating the Wald interval
WaldInterval <- function(x, n, z, print=FALSE) {
p <= x/n
upper <- p + z* sqrt(p*(1-p)/n)
lower <- p - z* sqrt(p*(1-p)/n)
print(upper)
}
print(WaldInterval(sum(samples), n, z))
#function for calculating the Wald interval
WaldInterval <- function(x, n, z, print=FALSE) {
p <= x/n
upper <- p + z* sqrt(p*(1-p)/n)
lower <- p - z* sqrt(p*(1-p)/n)
print(upper)
print(lower)
}
print(WaldInterval(sum(samples), n, z))
#function for calculating the Wilson interval
WilsonInterval <- function(x, n, z, print=FALSE) {
p <- x/n
upper <- (p + z ^ 2 / (2 * n ) ) / ( 1 + z^2/n) + ((sqrt(n)*z)/ (n + z^2)) * sqrt( p * (1-p) +z ^2 /(4*n))
lower <- (p +z ^ 2 / (2 * n) ) / (1 + z^2 /n) - ((sqrt(n)*z)/(n+z^2)) *sqrt(p*(1-p)+z^2/(4*n))
print(upper)
print(lower)
}
print(WilsonInterval(sum(samples), n, z))
print(WaldInterval(sum(samples),n,z))
require("xlsx")
require("xlsx")
library(xlsx)
require(xlsx)
install.packages("rJava",type='source')
install.packages("rJava",type='source')
install.packages("rJava",type='source')
sudo R CMD javareconf
sudo R CMD javareconf
pchisq(55.35,df=1)
pchisq(-55.35,df=1)
pnorm(7.43)
pnorm(7.441, mean=0, sd=1)
k=1000
p=0.999
transition_random_numbers = data.fram(c(0))
transition_random_numbers = data.frame(c(0))
names(transition_random_numbers)[1] <- paste("probability")
temp1=data.frame(runif(k-1)) #generate probability for HMM
View(temp1)
View(transition_random_numbers)
View(temp1)
View(temp1)
transition_random_numbers=rbind(transition_random_numbers, temp1)
names(temp1)[1] <-paste("probability")
transition_random_numbers=rbind(transition_random_numbers, temp1)
View(transition_random_numbers)
generated_HMM = data.frame(as.numeric(transition_random_numbers>p))
View(generated_HMM)
close.data <- read.csv(file="close_returns.csv", header=TRUE, sep=",")
setwd("~/projects/mathematical_modeling/term_project/Data")
close.data <- read.csv(file="close_returns.csv", header=TRUE, sep=",")
open.data <- read.csv(file="open_returns.csv", header=TRUE, sep=",")
low.data <- read.csv(file="low_returns.csv", header=TRUE, sep=",")
high.data <- read.csv(file="high_returns.csv", header=TRUE, sep=",")
View(close.data)
summary(close.data)
library(psych)
install.packages("psych")
library(psych)
summary(close.data)
describe(close.data)
describe(open.data)
describe(low.data)
describe(high.data)
close1.data <- read.csv(file="close_1_returns.csv", header=TRUE, sep=",")
close5.data <- read.csv(file="close_5_returns.csv", header=TRUE, sep=",")
close20.data <- read.csv(file="close_10_returns.csv", header=TRUE, sep=",")
close20.data <- read.csv(file="close_20_returns.csv", header=TRUE, sep=",")
library(psych)
describe(close.data)
describe(close1.data)
describe(close5.data)
describe(close20.data)
describe(close1.data)
describe(close5.data)
describe(close20.data)
